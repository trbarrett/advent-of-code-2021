inp w     w = [1..9]
mul x 0   x = 0
add x z   x = 0
mod x 26  x = 0
div z 1   z = 0
add x 10  x = 10
eql x w   x = (x = w ? 1 : 0)
eql x 0   x = !x
mul y 0   y = 0
add y 25  y = 25
mul y x   y = 0 or 25
add y 1   y = 1 or 26
mul z y   z = 0
mul y 0   y = 0
add y w   y = [1..9]
add y 2   y = [3..11]
mul y x   y = 0 or [3..11]
add z y   z = 0 or [3..11]
inp w     w = [1..9]
mul x 0   x = 0
add x z   x = z
mod x 26  x = z % 26 = [0; 3..11]
div z 1   z = z [0; 3..11]
add x 10  x = (z % 26) + 10
eql x w   x = 0 (z must be greater than 10)
eql x 0   x = 1
mul y 0   y = 0
add y 25  y = 25
mul y x   y = 25
add y 1   y = 26
mul z y   z = [0; 3..11] * 26 = [3..11] * 26
mul y 0   y = 0
add y w   y = [1..9]
add y 4   y = [5..13]
mul y x   y = [5..13]
add z y   z = [[5..13] + ([3..11] * 26)]
inp w     w = [1..9]
mul x 0   x = 0
add x z   x = z = [[5..13] + ([3..11] * 26)]
mod x 26  x = [[5..13] + ([3..11] * 26)] % 26
div z 1   z = z = [[5..13] + ([3..11] * 26)]
add x 14  x = [14..40]
eql x w   x = 0
eql x 0   x = 1
mul y 0   y = 0
add y 25  y = 25
mul y x   y = 25
add y 1   y = 26
mul z y   z = [[5..13] + ([3..11] * 26)] * 26
mul y 0   y = 0
add y w   y = [1..9]
add y 8   y = [9..17]
mul y x   y = [9..17]
add z y   z = [9..17] + ([[5..13] + ([3..11] * 26)] * 26)


...

last one


inp w     w = [1..9]
mul x 0   x = 0
add x z   x = z
mod x 26  x = [1..26]
div z 26  z = z/26
add x -2  x = -2..24]
eql x w   x = [0..1]
eql x 0   x = [0..1]
mul y 0   y = 0
add y 25  y = 25
mul y x   y = [0; 25]
add y 1   y = [1; 26]
mul z y   z = [z; 26*z]
mul y 0   y = 0
add y w   y = [1..9]
add y 11  y = [12..20]
mul y x   y = [0;12..20]
add z y   z = [z; [12..20] + z]



// z is never negative
// z gets a positive number added to it each time
// z gets divided by 26 a lot of times.... we have a good idea what y will be that multiplies it
// z gets divided by 0


// leaves a 0 if valid


// focus on z:


set x = z
mod x 26  x = [0..25]
div z 26  z = z/26
add x -2  x = [-2..23]
// range check w in x. If so x = 1

add y 1   y = [1; 26]
mul z y   z = [z; 26*z] (z * 1 or 26, depending on range check for x)

add y 11  y = [12..20]
mul y x   y = [0;12..20]

add z y   z = [z; [12..20] + z]

// we divide by 1 or 26, then we multiply by 1 or 26, then we add [1..9]+n




// try with an input working backwards

inp w    // w = 9
mul x 0  // x = 0
add x z   // z = 26*n + 11
mod x 26  // x = x%26 = 11 = 26*n + 11
div z 26  // z = ???
add x -2  // x = 11
eql x w   // x = 9



